use std

use "atomic"
use "futex"

pkg thread =
	/*
	Unfortunately OS X requires a separate implementation as `ftxtag` is 64
	bits here. We work around this by storing the value of the semaphore in
	the high 32 bits of the full value that we wait on. Although the struct
	is effectively an untagged union between 3 `uint32`s, a `uint64`
	followed by a `uint32`, and a `uint32` followed by a `uint64`, it still
	has 4 byte alignment, which is fine as one qword operation will always
	be unaligned.
	*/
	type sem = struct
		_pad      : uint32
		_val      : uint32
		_nwaiters : uint32
	;;

	const mksem      : (v : uint32 -> sem)
	const semwait    : (s : sem# -> void)
	const semtrywait : (s : sem# -> bool)
	const sempost    : (s : sem# -> void)
;;

const mksem = {v
	-> [._val = (v : ftxtag)]
}

const semwait = {s
	var v = 0

	xadd(&s._nwaiters, 1)
	for ; ;
		while (v = s._val) > 0
			if xcas(&s._val, v, v - 1) == v
				xadd(&s._nwaiters, -1)
				-> void
			;;
		;;
		ftxwait((&s._pad : ftxtag#), v, -1)
	;;
}

const semtrywait = {s
	for ; ;
		var v = xget(&s._val)
		if v == 0
			-> false
		;;
		if xcas(&s._val, v, v - 1) == v
			-> true
		;;
	;;
	-> false /* Unreachable */
}

const sempost = {s
	var state = xadd((&s._val : uint64#), 1)
	std.assert((state : uint32) != ~0x0, "error: semaphore overflowed\n")

	if (state >> 32) > 0
		ftxwake((&s._pad : ftxtag#))
	;;
}
