use std

use "common"
use "fsbase"
use "types"

pkg thread =
	const        gettlskey : (-> key)
	generic      tlsset    : (k : key, v : @a# -> void)
	generic      tlsget    : (k : key -> @a#)
	extern const tid       : (-> tid)

	pkglocal const        tlsoob  : (k : key -> void)
	pkglocal extern const tlslen  : (-> key)
;;

var _hdr
var _cap = 8

const gettlskey = {
	std.assert(tid() == 0, "error: gettlskey must be called from main thread\n")
	if _hdr == Zptr
		/* `_hdr` is lazily initialized here since we can't set it in start.s */
		_hdr = getfsbase()
	;;

	if _hdr.len++ == _cap
		std.assert(_cap < 0x8000_0000, "error: max tls slots exceeded\n")
		var l = sizeof(tlshdr) + ((_cap : std.size) * sizeof(void#))
		var h = std.bytealloc(sizeof(tlshdr) + ((_cap *= 2 : std.size) * sizeof(void#)))

		std.memblit(h, (_hdr : byte#), l)
		setfsbase((h : tlshdr#))
		/* this is ugly... the initial tls region is statically allocated */
		if _cap != 16
			std.bytefree((_hdr : byte#), l)
		;;
		_hdr = (h : tlshdr#)
	;;
	-> _hdr.len - 1
}

generic tlsset = {k, v
	_tlsset(k, (v : void#))
}

generic tlsget = {k
	-> (_tlsget(k) : @a#)
}

const tlsoob = {k
	std.fput(std.Err, "error: tls key out of bounds: {}\n", k)
	std.fput(std.Err, "fs: {}\nlen: {}\nhdr: {}\nhdr.len: {}\n",
		getfsbase(), tlslen(), _hdr, _hdr.len)
	std.suicide()
}

extern const _tlsset : (k : key, v : void# -> void)
extern const _tlsget : (k : key -> void#)
