use std
use sys

use "atomic"

pkg thread =
	type tid = sys.tid
	type key = uint32

	const   tlssetcap : (cap : uint32 -> void)
	const   tlsreg    : (-> key)
	generic tlsset    : (k : key, v : @a# -> void)
	generic tlsget    : (k : key -> @a#)

	extern const tid     : (-> tid)
	extern const _tlsset : (k : key, v : void# -> void)
	extern const _tlsget : (k : key -> void#)

	pkglocal type hdr = struct
		tid   : tid /* must be 32 bits */
		pad   : uint32  /* unused; could become stksz? */
		base  : byte#
		slots : void#[...]
	;;

	pkglocal var tlscap  : uint32 = 8
	pkglocal var spawned = false
;;

var tlslen : uint32 = 0
var tlsmain : hdr#

const __init__ = {
	tlsmain = (std.bytealloc(sizeof(hdr) + (8 * sizeof(void#))) : hdr#)
	sys.arch_prctl(sys.Archsetfs, (tlsmain : void#))
	tlsmain.tid = 0
}

const tlssetcap = {cap
	cap = cap + 1 & ~0x1
	/* Arbitarily chosen for now. `stksz` is currently fixed to 8MiB but... */
	std.assert(cap <= 1024, "error: cannot have more than 1024 tls slots\n")
	std.assert(!spawned, "error: tls capacity must be set before threads are spawned\n")
	std.bytefree((tlsmain : byte#), (tlscap : std.size) * sizeof(void#))
	tlsmain = (std.bytealloc(sizeof(hdr) + ((cap : std.size) * sizeof(void#))) : hdr#)
	sys.arch_prctl(sys.Archsetfs, (tlsmain : void#))
	tlsmain.tid = 0
	tlscap = cap
}

const tlsreg = {
	var k = xadd(&tlslen, 1)
	std.assert(k < tlscap, "error: tls capacity exceeded\n")
	-> (k : key)
}

generic tlsset = {k, v
	std.assert((k : uint32) < tlslen, "error: tls index out of bounrs\n")
	_tlsset(k, (v : void#))
}

generic tlsget = {k
	std.assert((k : uint32) < tlslen, "error: tls index out of bounrs\n")
	-> (_tlsget(k) : @a#)
}
