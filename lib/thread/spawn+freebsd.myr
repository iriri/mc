use sys
use std

use "common"
use "fsbase"
use "tls"
use "types"

pkg thread =
	const spawn : (fn : (-> void) -> std.result(tid, byte[:]))
;;


const Stacksz = 8*std.MiB
extern const exit : (-> void)

var stkbase : std.intptr = 0x10_0000_0000

const spawn = {fn
	-> spawnstk(fn, Stacksz)
}

const spawnstk = {fn, sz
	var stk, tos, hdr, ret

	stk = getstk(sz)
	if stk == sys.Mapbad
		-> `std.Err "couldn't get stack"
	;;
	(tos, sz, hdr) = initstk(stk, fn, sz)

	ret = sys.thr_new(&[
		.startfn = (startthread : void#),
		.arg = (tos : void#),
		.stkbase = (stk : byte#),
		.stksz = sz,
		.tid = (&hdr.tid : uint64#),
		.ptid = Zptr,
		.flags = 2,
		.rtp = Zptr,
	], sizeof(sys.thrparam))

	if ret < 0
		-> `std.Err "couldn't spawn thread"
	;;
	-> `std.Ok (ret : tid)
}

const initstk = {stk, fn, sz
	var len, tlssz, tos, hdr, fp, env, envsz

	len = tlslen()
	tlssz = (sizeof(tlshdr) + ((len : sys.size) * sizeof(void#)) + 0xf) & ~0xf
	sz -= tlssz
	tos = (stk : std.intptr) + (sz : std.intptr)
	hdr = (tos : tlshdr#)
	hdr.stksz = (sz : uint32)
	hdr.tlssz = (tlssz : uint32)

	var fn1 = {
		/*
		We write `hdr.len` here because it follows `hdr.tid` so it gets
		overwritten by the kernel in `thr_new`. Even though `sys.pid`
		is 32 bits, `thr_param.tid` is a `uint64#` for legacy reasons.
		*/
		hdr.len = len
		setfsbase(hdr)
		fn()
	}

	envsz = std.fnenvsz(fn1)
	tos -= (envsz : std.intptr)
	sz -= (envsz : sys.size)
	env = tos
	tos -= sizeof((->void))
	sz -= sizeof((->void))
	fp = (tos : (->void)#)
	fp# = std.fnbdup(fn1, (env : byte#)[:envsz])
	-> ((tos : byte#), sz, hdr)
}

const getstk = {sz
	-> sys.mmap((0 : byte#), sz, sys.Mprotrw, sys.Mpriv | sys.Manon, -1, 0)
}

const startthread = {f : (-> void)#
	f#()
	exit()
}

