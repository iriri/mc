use std
use sys

use "atomic"
use "common"
use "mutex"
use "sem"

pkg thread =
	type cond = struct
		_mtx	: mutex#
		_head	: condwaiter#
		_tail	: condwaiter#
		_lock	: mutex
	;;

	const mkcond	: (mtx : mutex# -> cond)
	const condwait	: (cond : cond# -> void)
	const condsignal	: (cond : cond# -> void)
	const condbroadcast	: (cond : cond# -> void)
;;

type condwaiter = struct
	next : condwaiter#
	sem : sem
;;

const mkcond = {mtx
	-> [._mtx = mtx, ._lock = mkmtx()]
}

const condwait = {cond
	var mtx = cond._mtx
	var lock = &cond._lock
	var w = std.mk([.sem = mksem(0)])

	mtxlock(lock)
	if cond._tail != Zptr
		cond._tail.next = w
	else
		cond._head = w
	;;
	cond._tail = w
	mtxunlock(lock)

	mtxunlock(cond._mtx)
	semwait(&w.sem)

	std.free(w)

	/*
	We need to atomically set the mutex to contended. This allows us to
	pass responsibility for waking up the potential other waiters on to the
	unlocker of the mutex.
	*/
	mtxcontended(cond._mtx)
}

const condsignal = {cond
	var lock = &cond._lock

	mtxlock(lock)
	var w = cond._head
	if w != Zptr
		cond._head = w.next
		sempost(&w.sem)
		if cond._head == Zptr
			cond._tail = Zptr
		;;
	;;
	mtxunlock(lock)
}

/*
Yes, this invites the thundering herd but that's what you get for not having a
requeue operation.
*/
const condbroadcast = {cond
	var lock = &cond._lock
	var w = Zptr

	mtxlock(lock)
	while (w = cond._head) != Zptr
		cond._head = w.next
		sempost(&w.sem)
	;;
	cond._tail = Zptr
	mtxunlock(lock)
}
