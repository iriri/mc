use std

use "atomic"
use "futex"

pkg thread =
	type rwlock = struct
		_state : ftxtag /* _nreaders:31 : uint32, _wbit:1 : uint32 */
	;;

	const mkrw       : (-> rwlock)
	const rwrlock    : (rw : rwlock# -> void)
	const rwwlock    : (rw : rwlock# -> void)
	const rwtryrlock : (rw : rwlock# -> bool)
	const rwtrywlock : (rw : rwlock# -> bool)
	const rwrunlock  : (rw : rwlock# -> void)
	const rwwunlock  : (rw : rwlock# -> void)
;;

const Nrmask = 0x7fffffff
const Wbit   = 0x80000000

const mkrw = {
	-> [._state = 0]
}

const rwrlock = {rw
	for ; ;
		var s = xget(&rw._state)
		match s & Nrmask
		| Nrmask - 1: std.die("error: rwlock overflowed\n")
		| Nrmask:
			if xcas(&rw._state, s, Nrmask | Wbit) == s
				ftxwait(&rw._state, Nrmask | Wbit, 0)
			;;
		| _:
			if xcas(&rw._state, s, s + 1) == s
				-> void
			;;
		;;
	;;
}

const rwwlock = {rw
	for ; ;
		var s = xcas(&rw._state, 0, Nrmask)
		if s == 0
			-> void
		;;

		if xcas(&rw._state, s, s | Wbit) == s
			ftxwait(&rw._state, s | Wbit, 0)
		;;
	;;
}

const rwtryrlock = {rw
	for ; ;
		var s = xget(&rw._state)
		match s & Nrmask
		| Nrmask - 1: std.die("error: rwlock overflowed\n")
		| Nrmask: -> false
		| _:
			if xcas(&rw._state, s, s + 1) == s
				-> true
			;;
		;;
	;;
	-> false /* Unreachable */
}

const rwtrywlock = {rw
	-> xcas(&rw._state, 0, Nrmask) == 0
}

const rwrunlock = {rw
	var prev = xadd(&rw._state, -1)
	std.assert(prev & Nrmask != 0, "error: rwlock underflowed\n")
	if prev & Nrmask == 1 && prev & Wbit != 0
		if xcas(&rw._state, Wbit, 0) == Wbit
			ftxwake(&rw._state)
		;;
	;;
}

const rwwunlock = {rw
	if xchg(&rw._state, 0) & Wbit != 0
		ftxwakeall(&rw._state) /* Just Do It(tm). */
	;;
}
